#include <reg51.h>
#include <intrins.h>
#define uchar unsigned char
#define xData  P1
#define	Shift		0x1C
uchar data_4byte[4];
void delayus(uchar m);
void delayms(uchar m);
void change	(uchar dat);
void Fill_RAM(unsigned char Data) ;
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Global Variables
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#define	Shift		0x1C
#define Max_Column	0x3F			// 256/4-1
#define Max_Row		0x3F			// 64-1
#define	Brightness	0x0F

//#define	SPI
//#define	I80
#define	M68

sbit REST=P3^4;    // Reset
sbit CS=P3^3;    // Chip Select
sbit DC=P3^0;    // Data/Command Control
sbit RW=P3^1;    // Write Signal
sbit E=P3^2;    // E Signal
sbit _WR=P3^1;    
sbit _RD=P3^2;    
sbit SCLK=P1^0;    
sbit SDIN=P1^1; 

uchar code tab88[]={
    0x0e,0x11,0x11,0x11,0x15,0x12,0x0b,0x00,// Q 代码"31"
    0x0e,0x11,0x11,0x11,0x15,0x12,0x0b,0x00,// Q 代码"31"
    0x1f,0x02,0x04,0x02,0x01,0x11,0x0e,0x00,// 3 代码"13"
    0x0e,0x11,0x11,0x0e,0x11,0x11,0x0e,0x00,// 8 代码"18"
	0x04,0x0c,0x04,0x04,0x04,0x04,0x0e,0x00,//1 代码"11"
	0x04,0x0c,0x04,0x04,0x04,0x04,0x0e,0x00,//1 代码"11"
    0x0e,0x11,0x11,0x0e,0x01,0x02,0x0c,0x00,// 9 代码"19"
	0x0e,0x11,0x11,0x0e,0x11,0x11,0x0e,0x00,// 8 代码"18"
	0x02,0x06,0x0a,0x12,0x1f,0x02,0x02,0x00,// 4 代码"14"
	0x06,0x08,0x10,0x1e,0x11,0x11,0x0e,0x00,// 6 代码"16"
	0x02,0x06,0x0a,0x12,0x1f,0x02,0x02,0x00,// 4 代码"14"
    0x11,0x11,0x11,0x1f,0x11,0x11,0x11,0x00,// H 代码"28"
	0x0e,0x04,0x04,0x04,0x04,0x04,0x0e,0x00,// I 代码"29"
	0x07,0x02,0x02,0x02,0x02,0x12,0x0c,0x00,// J 代码"2A"
	0x11,0x12,0x14,0x18,0x14,0x12,0x11,0x00,// K 代码"2B"
	0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x00,// L 代码"2C"
	0x11,0x1b,0x15,0x11,0x11,0x11,0x11,0x00,// M 代码"2D"
	0x11,0x19,0x19,0x15,0x13,0x13,0x11,0x00,// N 代码"2E"
	0x0e,0x11,0x11,0x11,0x11,0x11,0x0e,0x00,// O 代码"2F"
	0x1e,0x11,0x11,0x1e,0x10,0x10,0x10,0x00,// P 代码"30"
	0x0e,0x11,0x11,0x11,0x15,0x12,0x0b,0x00,// Q 代码"31"
	0x1e,0x11,0x11,0x1e,0x14,0x12,0x11,0x00,//R 代码"32"
	0x0e,0x11,0x10,0x0e,0x01,0x11,0x0e,0x00,// S 代码"33"
	0x1f,0x04,0x04,0x04,0x04,0x04,0x04,0x00,// T 代码"34"
	0x11,0x11,0x11,0x11,0x11,0x11,0x0e,0x00,// U 代码"35"
	0x11,0x11,0x11,0x11,0x11,0x0a,0x04,0x00,// V 代码"36"
	0x11,0x11,0x11,0x15,0x15,0x1b,0x11,0x00,// W 代码"37"
	0x11,0x11,0x0a,0x04,0x0a,0x11,0x11,0x00,// X 代码"38"
	0x11,0x11,0x11,0x0a,0x04,0x04,0x04,0x00,// Y 代码"39"
	0x1f,0x01,0x02,0x04,0x08,0x10,0x1f,0x00,// Z 代码"3A"
	0x0e,0x08,0x08,0x08,0x08,0x08,0x0e,0x00,// [ 代码"3B"
	0x00,0x10,0x08,0x04,0x02,0x01,0x00,0x00,// \ 代码"3C"
	0x0e,0x02,0x02,0x02,0x02,0x02,0x0e,0x00,// ] 代码"3D"
	0x04,0x0a,0x11,0x00,0x00,0x00,0x00,0x00,// ^ 代码"3E"
	0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x00,// _ 代码"3F"
	0x10,0x08,0x04,0x00,0x00,0x00,0x00,0x00,// ` 代码"40"
	0x00,0x00,0x0e,0x01,0x0f,0x11,0x0f,0x00,// a 代码"41"
	0x10,0x10,0x16,0x19,0x11,0x11,0x1e,0x00,// b 代码"42"
	0x00,0x00,0x0e,0x11,0x10,0x11,0x0e,0x00,// c 代码"43"
	0x01,0x01,0x0d,0x13,0x11,0x11,0x0f,0x00,// d 代码"44"
	0x00,0x00,0x0e,0x11,0x1f,0x10,0x0e,0x00,// e 代码"45"
	0x02,0x05,0x04,0x0e,0x04,0x04,0x04,0x00,// f 代码"46"
	0x00,0x0d,0x13,0x13,0x0d,0x01,0x0e,0x00,// g 代码"47"
	0x10,0x10,0x16,0x19,0x11,0x11,0x11,0x00,// h 代码"48"
	0x04,0x00,0x0c,0x04,0x04,0x04,0x0e,0x00,// i 代码"49"
	0x02,0x00,0x06,0x02,0x02,0x12,0x0c,0x00,// j 代码"4A"
	0x08,0x08,0x09,0x0a,0x0c,0x0a,0x09,0x00,//k 代码"4B"
	0x0c,0x04,0x04,0x04,0x04,0x04,0x0e,0x00,// l 代码"4C"
	0x00,0x00,0x1a,0x15,0x15,0x15,0x15,0x00,// m 代码"4D"
	0x00,0x00,0x16,0x19,0x11,0x11,0x11,0x00,// n 代码"4E"
	0x00,0x00,0x0e,0x11,0x11,0x11,0x0e,0x00,// o 代码"4F"
	0x00,0x16,0x19,0x19,0x16,0x10,0x10,0x00,// p 代码"50"
	0x00,0x0d,0x13,0x13,0x0d,0x01,0x01,0x00,// q 代码"51"
	0x00,0x00,0x16,0x19,0x10,0x10,0x10,0x00,// r 代码"52"
	0x00,0x00,0x0f,0x10,0x1e,0x01,0x1f,0x00,// s 代码"53"
	0x08,0x08,0x1c,0x08,0x08,0x09,0x06,0x00,// t 代码"54"
	0x00,0x00,0x12,0x12,0x12,0x12,0x0d,0x00,// u 代码"55"
	0x00,0x00,0x11,0x11,0x11,0x0a,0x04,0x00,// v 代码"56"
	0x00,0x00,0x11,0x11,0x15,0x15,0x0a,0x00,// w 代码"57"
	0x00,0x00,0x11,0x0a,0x04,0x0a,0x11,0x00,// x 代码"58"
	0x00,0x00,0x11,0x11,0x13,0x0d,0x01,0x0e,// y 代码"59"

};
uchar code tab816[160]={
/*--  文字:  H  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,
/*--  文字:  G  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x3C,0x44,0x44,0x80,0x80,0x80,0x8E,0x84,0x44,0x44,0x38,0x00,0x00,
/*--  文字:  S  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x3E,0x42,0x42,0x40,0x20,0x18,0x04,0x02,0x42,0x42,0x7C,0x00,0x00,
/*--  文字:  2  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x04,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00,
 /*--  文字:  5  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x58,0x64,0x02,0x02,0x42,0x44,0x38,0x00,0x00,
/*--  文字:  6  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x1C,0x24,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x24,0x18,0x00,0x00,
/*--  文字:  X  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x18,0x18,0x18,0x24,0x24,0x42,0xE7,0x00,0x00,
/*--  文字:  6  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x1C,0x24,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x24,0x18,0x00,0x00,
/*--  文字:  4  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x24,0x44,0x44,0x7E,0x04,0x04,0x1E,0x00,0x00,
/*--  文字:  1  --*/
/*--  Times New Roman12;  此字体下对应的点阵为：宽x高=8x16   --*/
0x00,0x00,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,

};
uchar code tab1616[]={
/* 点阵：16x16
   提取点阵方向：横向（先左->右, 再上->下）
   字节掉转：否
   字节方式：C语言 */
0x00,0x40,0x40,0x48,0x37,0xFC,0x10,0x40,    // 清
0x83,0xF8,0x60,0x40,0x2F,0xFE,0x08,0x08,
0x13,0xFC,0x22,0x08,0xE3,0xF8,0x22,0x08,
0x23,0xF8,0x22,0x08,0x22,0x28,0x22,0x10,

0x00,0x80,0x40,0x80,0x20,0x80,0x20,0x80,    // 达
0x00,0x88,0x0F,0xFC,0xE0,0x80,0x21,0x00,
0x21,0x40,0x22,0x20,0x22,0x10,0x24,0x18,
0x28,0x08,0x50,0x06,0x8F,0xFC,0x00,0x00,

0x01,0x00,0x21,0x08,0x11,0x0C,0x09,0x10,    // 光
0x09,0x20,0x01,0x04,0xFF,0xFE,0x04,0x40,
0x04,0x40,0x04,0x40,0x04,0x40,0x08,0x40,
0x08,0x42,0x10,0x42,0x20,0x3E,0x40,0x00,

0x02,0x00,0x02,0x00,0x02,0x10,0x7F,0xF8,    // 电
0x42,0x10,0x42,0x10,0x7F,0xF0,0x42,0x10,
0x42,0x10,0x7F,0xF0,0x42,0x10,0x02,0x00,
0x02,0x04,0x02,0x04,0x01,0xFC,0x00,0x00,

0x04,0x10,0x0E,0x10,0xF8,0x90,0x08,0x50,    // 科
0x08,0x10,0xFE,0x90,0x08,0x50,0x1C,0x14,
0x1A,0x1E,0x29,0xF0,0x28,0x10,0x48,0x10,
0x88,0x10,0x08,0x10,0x08,0x10,0x08,0x10,

0x10,0x40,0x10,0x40,0x10,0x48,0x13,0xFC,    // 技
0xFC,0x40,0x10,0x40,0x10,0x40,0x13,0xF8,
0x1A,0x08,0x31,0x10,0xD1,0x10,0x10,0xA0,
0x10,0x40,0x10,0xB0,0x51,0x0E,0x26,0x04,

0x02,0x00,0x02,0x04,0xFF,0xFE,0x04,0x00,    // 有
0x04,0x10,0x0F,0xF8,0x08,0x10,0x18,0x10,
0x2F,0xF0,0x48,0x10,0x88,0x10,0x0F,0xF0,
0x08,0x10,0x08,0x10,0x08,0x50,0x08,0x20,

0x00,0x08,0x7D,0xFC,0x45,0x08,0x49,0x08,    // 限
0x49,0xF8,0x51,0x08,0x49,0x08,0x49,0xF8,
0x45,0x04,0x45,0x88,0x45,0x50,0x69,0x20,
0x51,0x10,0x41,0x4E,0x41,0x84,0x41,0x00,

0x00,0x00,0x00,0x80,0x04,0x80,0x04,0x40,    // 公
0x08,0x40,0x08,0x20,0x11,0x10,0x21,0x0E,
0xC2,0x04,0x02,0x00,0x04,0x00,0x08,0x40,
0x10,0x20,0x1F,0xF0,0x00,0x10,0x00,0x00,

0x00,0x08,0x3F,0xFC,0x00,0x08,0x00,0x48,    // 司
0xFF,0xE8,0x00,0x08,0x00,0x88,0x3F,0xC8,
0x20,0x88,0x20,0x88,0x20,0x88,0x20,0x88,
0x3F,0x88,0x20,0x88,0x00,0x28,0x00,0x10,


};

/*********************
延时子程序
********************/
void delayus(uchar m)
{
while(--m);
}
void delayms(uchar m)
{
uchar i,j;
for(i=0;i<102;i++)
for(j=0;j<m;j++)
delayus(1);
}
void delay(uchar m)
{
uchar i,j;
for(i=0;i<100;i++)
for(j=0;j<m;j++)
delayms(1);
}

#ifdef M68
void Write_cmd(unsigned char Data) //68XX方式写指令子程序
{       DC=0;
	CS=0;
	RW=0;
	xData=Data;
        E=1;
        _nop_();
        _nop_();
        E=0;
	RW=1;
	CS=1;
	DC=1;
}

void Write_dat(unsigned char Data) //68XX方式写数据子程序
{        DC=1;
	 CS=0;
	RW=0;
	xData=Data;
         E=1;
        _nop_();
        _nop_();
        E=0;
	RW=1;
 	CS=1;
	DC=1;
}
#endif
#ifdef I80					// 8-bit 80XX Parallel
void Write_cmd(unsigned char Data)
{
	DC=0;
	CS=0;
	_WR=0;
	xData=Data;
	_WR=1;
	CS=1;
	DC=1;
}


void Write_dat(unsigned char Data)
{
	DC=1;
	CS=0;
	_WR=0;
	xData=Data;
	_WR=1;
	CS=1;
	DC=1;
}
#endif


#ifdef SPI					// 4-wire SPI
void Write_cmd(unsigned char Data)
{
unsigned char i;

	CS=0;
	DC=0;
	for (i=0; i<8; i++)
	{
		SCLK=0;
		SDIN=(Data&0x80)>>7;
		Data = Data << 1;
//		uDelay(1);
		SCLK=1;
//		uDelay(1);
	}
//	SCLK=0;
	DC=1;
	CS=1;
}


void Write_dat(unsigned char Data)
{
unsigned char i;

	CS=0;
	DC=1;
	for (i=0; i<8; i++)
	{
		SCLK=0;
		SDIN=(Data&0x80)>>7;
		Data = Data << 1;
//		uDelay(1);
		SCLK=1;
//		uDelay(1);
	}
//	SCLK=0;
	DC=1;
	CS=1;
}
#endif
/********************************************
行，列，起始地址设定，写入命令定义 一个像素对应4位
********************************************/
void Set_Column_Address(unsigned char a, unsigned char b)
{
	Write_cmd(0x15);			// Set Column Address
	Write_dat(a);				//   Default => 0x00
	Write_dat(b);				//   Default => 0x77
}


void Set_Row_Address(unsigned char a, unsigned char b)
{
	Write_cmd(0x75);			// Set Row Address
	Write_dat(a);				//   Default => 0x00
	Write_dat(b);				//   Default => 0x7F
}

void Set_Write_RAM()
{
	Write_cmd(0x5C);			// Enable MCU to Write into RAM
}

void Set_Remap_Format(unsigned char d)
{
	Write_cmd(0xA0);			// Set Re-Map / Dual COM Line Mode
	Write_dat(d);				//   Default => 0x40
	Write_dat(0x11);			//   Default => 0x01 (Disable Dual COM Mode)
}

/* ***********************************
//初始化程序
***************************************/
void Initial (void)
{
    REST=0;
	delayms(100);
	REST=1;
    delayms(100);
	Write_cmd(0xFD);
 	Write_dat(0x12);  							//打开MCU通信

	Set_Column_Address(0x1c,0x5b);	//256列
	Set_Row_Address(0x00,0x3f);		  //64行

	Write_cmd(0xAE);  							//开休眠

	Write_cmd(0xB3);  							///驱动和振荡时钟
	Write_dat(0x91);

	Write_cmd(0xCA); ///设定MUX占空比
	Write_dat(0x3F);

	Write_cmd(0xA2);
	Write_dat(0x00); //卷动地址

	Write_cmd(0xA1);
	Write_dat(0x00); //起始行

        Write_cmd(0xA6);	  //正常显示

	Write_cmd(0xA0);
 	Write_dat(0x14);
	Write_dat(0x11);  //扫描方向

	Write_cmd(0xB5); ///set gpio
	Write_dat(0x00);

	Write_cmd(0xAB);
	Write_dat(0x01); //内部调节电压

	Write_cmd(0xB4); ///加深显示Display Enhancement a
	Write_dat(0xA0);
	Write_dat(0xfd);   //0xb5

	Write_cmd(0xC1); ///Set Contrast Current
	Write_dat(0xaf); //9f

	Write_cmd(0xC7);  //Master Contrast	Current Control
	Write_dat(0x0F);

	Write_cmd(0xb8);  //灰模
	Write_dat(0x0c);
	Write_dat(0x18);
	Write_dat(0x24);
	Write_dat(0x30);
	Write_dat(0x3c);
	Write_dat(0x48);
	Write_dat(0x54);
	Write_dat(0x60);
 	Write_dat(0x6c);
	Write_dat(0x78);
	Write_dat(0x84);
	Write_dat(0x90);
	Write_dat(0x9c);
	Write_dat(0xa8);
	Write_dat(0xb4);

	Write_cmd(0x00);
	Write_cmd(0xB1); //Set Phase Length
	Write_dat(0xE2);

	Write_cmd(0xD1); //Display Enhancement B
	Write_dat(0xa2);
	Write_dat(0x20);//反显

	Write_cmd(0xBB);
	Write_dat(0x1F);

	Write_cmd(0xB6);
	Write_dat(0x08);

 	Write_cmd(0xBE);
	Write_dat(0x07);//0.86VCC

 	Write_cmd(0xA7);//正常显示
	Write_cmd(0xA9);//退部分显示
	Write_cmd(0x5c);
	Fill_RAM(0x00);
        Write_cmd(0xAF);  //关休眠
}

/***************************************
全和间隔列显示
**************************************/

void Fill_RAM(unsigned char Data)
{
unsigned char i,j;

	Set_Column_Address(0x1c,0x5b);
	Set_Row_Address(0x00,0x3f);
	Set_Write_RAM();

	for(i=0;i<64;i++)
	{
		for(j=0;j<64;j++)
		{
			Write_dat(Data);
			Write_dat(Data);
		}
	}
}
/***************************************
间隔行显示
**************************************/

void hang(unsigned char Data)
{
unsigned char i,j;

	Set_Column_Address(0x1c,0x5b);
	Set_Row_Address(0x00,0x3f);
	Set_Write_RAM();

	for(i=0;i<32;i++)
	{
		for(j=0;j<64;j++)
		{
			Write_dat(Data);
			Write_dat(Data);
		}
			for(j=0;j<64;j++)
		{
			Write_dat(~Data);
			Write_dat(~Data);
		}
	}
}


/***************************************
间隔点显示
**************************************/
void gedot(uchar m)
{
    unsigned char i,j;

	Set_Column_Address(0x1c,0x5b);	   //256列
	Set_Row_Address(0x00,0x3f);		 //128行
	Set_Write_RAM();

	for(i=0;i<32;i++)
	{
		for(j=0;j<64;j++)
		{
		   if(m==0xf0)
		   {
		Write_dat(0xf0);
	    	Write_dat(0xf0);
			}
			else
			{
		Write_dat(0x0f);
	    	Write_dat(0x0f);
			}
		}
		for(j=0;j<64;j++)
		{
                        if(m==0xf0)
		   {
		Write_dat(0x0f);
	    	Write_dat(0x0f);
			}
		else
		{
		Write_dat(0xf0);
	    	Write_dat(0xf0);
			}
		}
	}
}
/*****************************************************
 矩形边框
*********************************************************/
  void biank()
  {
     unsigned char i,j;

             Set_Remap_Format(0x14);
	  Write_cmd(0x15);
              Write_dat(0x1c);
	  Write_dat(0x5b);

              Write_cmd(0x75);
	  Write_dat(0x00);
	  Write_dat(0x00);
              Write_cmd(0x5c);

	for(i=0;i<64;i++)
	{
            Write_dat(0xff);
	Write_dat(0xff);
	}
              Write_cmd(0x75);
	  Write_dat(0x3f);
	  Write_dat(0x3f);
              Write_cmd(0x5c);

	for(i=0;i<64;i++)
	{
            Write_dat(0xff);
	Write_dat(0xff);
	}

            Set_Remap_Format(0x15);
	  Write_cmd(0x15);
              Write_dat(0x1c);
	  Write_dat(0x1c);
              Write_cmd(0x75);
	  Write_dat(0x01);
	  Write_dat(0x3e);
              Write_cmd(0x5c);
            for(i=0;i<64;i++)
	{
            Write_dat(0xf0);
	Write_dat(0x00);
	}
            Write_cmd(0x15);
            Write_dat(0x5b);
	Write_dat(0x5b);
            Write_cmd(0x5c);
            for(i=0;i<64;i++)
	{
            Write_dat(0x00);
	Write_dat(0x0f);
	}
            Set_Remap_Format(0x14);
}


/************************************************
转换函数，D7=1,一位转换成四位
************************************************/
void change	(uchar m)
{
      uchar k;
  uchar kk,kkk;
  kk=m;
  for(k=0;k<4;k++)   // 一两位的方式写入  2*4=8位
   {
     kkk=kk&0xc0;     //当K=0时 为D7,D6位 当K=1时 为D5,D4位

     /****出现4种可能，16阶色素,一个地址两个像素，一个像素对应4位***/

     switch(kkk)
       {
	 case 0x00:
           data_4byte[k]=0x00;
         break;
         case 0x40:
           data_4byte[k]=0x0f;
         break;
	 case 0x80:
           data_4byte[k]=0xf0;
         break;
         case 0xc0:
           data_4byte[k]=0xff;
         break;
      	 default:
      	 break;
	   }
      kk=kk<<2;                                //左移两位
      Write_dat(data_4byte[k]);                /* 8 column  a nibble of command is a dot*/
   }
}

/**********************************************************
在显示屏上写一个8*16的数字
// 用字模表tab816(1维数组),
//在坐标（x坐标）（y坐标）位置显示一行字（左上脚坐标），
//其中x坐标必须为偶数。
//字占row行，一行col点。
//以上定义都是unsigned char全局变量，
************************************************************/

void write_oled(uchar x,uchar y,uchar coder)
{
 uchar dat;
 uchar i;
	  Set_Remap_Format(0x14);     //定义2个地址，1个字节
	  Write_cmd(0x15);
    Write_dat(0x1c+x);
	  Write_dat(0x1d+x);

    Write_cmd(0x75);              //16行
	  Write_dat(0x00+y);
	  Write_dat(0x10+y);
    
	  Write_cmd(0x5c);
	   for(i=0;i<16;i++)
	   {
        dat=tab816[i+16*coder];
				change(dat);
	 	}
	 }
/*********************************************************
 写入一行8*16的数字
****************************************************/
   void string816(uchar x,uchar y,uchar m)
   {
   uchar i;
   for(i=0;i<m;i++)
   {
   write_oled(x,y,i);
   x=x+4;delay(2);
   } }
/*********************************************************
 写入一行8*8的数字
****************************************************/
void write_oled8(uchar x,uchar y,uchar coder)
{
 uchar dat;
 uchar i;
	  Set_Remap_Format(0x14);     //定义2个地址，1个字节
	  Write_cmd(0x15);
          Write_dat(0x1c+x);
	  Write_dat(0x1d+x);

          Write_cmd(0x75);              //16行
	  Write_dat(0x00+y);
	  Write_dat(0x08+y);
    Write_cmd(0x5c);
	   for(i=0;i<8;i++)
	   {
        dat=tab88[i+8*coder];
	change(dat);
	 	}
	 }
/*********************************************************
 写入一行8*8的数字
****************************************************/
   void string88(uchar x,uchar y,uchar m)
   {
   uchar i;
   for(i=0;i<m;i++)
   {
   write_oled8(x,y,i);
   x=x+2;
   } }

/**********************************************************
在显示屏上写一个16*16的汉字
// 用字模表tab1616(1维数组),
//在坐标（x坐标）（y坐标）位置显示一行字（左上脚坐标），
//其中x坐标必须为偶数。
//字占row行，一行col点。
//以上定义都是unsigned char全局变量，coder为代码值
************************************************************/

void hzwrite_oled(uchar x,uchar y,uchar coder)
{
 uchar dat;
 uchar i;

	  Set_Remap_Format(0x14);    //定义4个地址，2个字节
	  Write_cmd(0x15);
          Write_dat(0x1c+x);
	  Write_dat(0x1f+x);

          Write_cmd(0x75);         //16行
	  Write_dat(0x00+y);
	  Write_dat(0x10+y);
          Write_cmd(0x5c);
	   for(i=0;i<32;i++)
	   {
        dat=tab1616[i+32*coder];
	change(dat);
	 	}

	 }
//***********************************************
// 写入一行汉字
/**********************************************/
  void stinghz(uchar x,uchar y,uchar m)
  {
   uchar i;
   for(i=0;i<m;i++)
   {
    hzwrite_oled(x,y,i);
    x=x+6; delay(2);
   }
   }
/*********************************************
  卷动程序
**********************************************/
void Set_Partial_Display(unsigned char a, unsigned char b, unsigned char c)
{

	Write_cmd(0xA8|a);
					// Default => 0x8F
						//   Select Internal Booster at Display On
	if(a == 0x00)
	{
		Write_dat(b);
		Write_dat(c);
	}
}
/*****************************************
  显示偏移量
********************************************/
void Set_Display_Offset(unsigned char d)
{
	Write_cmd(0xA2);			// Set Vertical Scroll by Row
	Write_dat(d);				//   Default => 0x00
}
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Vertical Scrolling (Full Screen)
//
//    a: Scrolling Direction
//       "0x00" (Upward)
//       "0x01" (Downward)
//    b: Set Numbers of Row Scroll per Step
//    c: Set Time Interval between Each Scroll Step
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void Vertical_Scroll(unsigned char a, unsigned char b, unsigned char c)
{
unsigned int i,j;

	Set_Partial_Display(0x00,0x00,Max_Row);

	switch(a)
	{
		case 0:
			for(i=0;i<(Max_Row+1);i+=b)
			{
				Set_Display_Offset(i+1);
				for(j=0;j<c;j++)
				{
					delayus(100);
				}
			}
			break;
		case 1:
			for(i=0;i<(Max_Row+1);i+=b)
			{
				Set_Display_Offset(Max_Row-i);
				for(j=0;j<c;j++)
				{
					delayus(100);
				}
			}
			break;
	}
	Set_Partial_Display(0x01,0x00,0x00);
}
/*********************************
     起始行
**********************************/
void Set_Start_Line(unsigned char d)
{
	Write_cmd(0xA1);			// Set Vertical Scroll by RAM
	Write_dat(d);				//   Default => 0x00
}
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Vertical Fade Scrolling (Full Screen)
//
//    a: Scrolling Direction
//       "0x00" (Upward - In)
//       "0x01" (Downward - In)
//       "0x02" (Upward - Out)
//       "0x03" (Downward - Out)
//    b: Set Numbers of Row Scroll per Step
//    c: Set Time Interval between Each Scroll Step
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void Fade_Scroll(unsigned char a, unsigned char b, unsigned char c)
{
unsigned int i,j;

	Set_Partial_Display(0x00,0x00,Max_Row);

	switch(a)
	{
		case 0:
			for(i=(Max_Row+1);i<128;i+=b)
			{
				Set_Start_Line(i);
				for(j=0;j<c;j++)
				{
					delayus(100);
				}
			}
			Set_Start_Line(0x00);
			for(j=0;j<c;j++)
			{
				delayus(100);
			}
			break;
		case 1:
			for(i=0;i<(Max_Row+1);i+=b)
			{
				Set_Start_Line(Max_Row-i);
				for(j=0;j<c;j++)
				{
					delayus(100);
				}
			}
			break;
		case 2:
			for(i=0;i<(Max_Row+1);i+=b)
			{
				Set_Start_Line(i+1);
				for(j=0;j<c;j++)
				{
					delayus(100);
				}
			}
			break;
		case 3:
			for(i=127;i>Max_Row;i-=b)
			{
				Set_Start_Line(i);
				for(j=0;j<c;j++)
				{
					delayus(100);
				}
			}
			break;
	}
	Set_Partial_Display(0x01,0x00,0x00);
}
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Show Regular Pattern (Partial or Full Screen)
//
//    a: Column Address of Start
//    b: Column Address of End (Total Columns Devided by 4)
//    c: Row Address of Start
//    d: Row Address of End
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void Fill_Block(unsigned char Data, unsigned char a, unsigned char b, unsigned char c, unsigned char d)
{
unsigned char i,j;

	Set_Column_Address(Shift+a,Shift+b);
	Set_Row_Address(c,d);
	Set_Write_RAM();

	for(i=0;i<(d-c+1);i++)
	{
		for(j=0;j<(b-a+1);j++)
		{
			Write_dat(Data);
			Write_dat(Data);
		}
	}
}
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  Show Gray Scale Bar (Full Screen)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void Grayscale()
{
	// Level 16 => Column 1~16
		Fill_Block(0xFF,0x00,0x03,0x00,Max_Row);

	// Level 15 => Column 17~32
		Fill_Block(0xEE,0x04,0x07,0x00,Max_Row);

	// Level 14 => Column 33~48
		Fill_Block(0xDD,0x08,0x0B,0x00,Max_Row);

	// Level 13 => Column 49~64
		Fill_Block(0xCC,0x0C,0x0F,0x00,Max_Row);

	// Level 12 => Column 65~80
		Fill_Block(0xBB,0x10,0x13,0x00,Max_Row);

	// Level 11 => Column 81~96
		Fill_Block(0xAA,0x14,0x17,0x00,Max_Row);

	// Level 10 => Column 97~112
		Fill_Block(0x99,0x18,0x1B,0x00,Max_Row);

	// Level 9 => Column 113~128
		Fill_Block(0x88,0x1C,0x1F,0x00,Max_Row);

	// Level 8 => Column 129~144
		Fill_Block(0x77,0x20,0x23,0x00,Max_Row);

	// Level 7 => Column 145~160
		Fill_Block(0x66,0x24,0x27,0x00,Max_Row);

	// Level 6 => Column 161~176
		Fill_Block(0x55,0x28,0x2B,0x00,Max_Row);

	// Level 5 => Column 177~192
		Fill_Block(0x44,0x2C,0x2F,0x00,Max_Row);

	// Level 4 => Column 193~208
		Fill_Block(0x33,0x30,0x33,0x00,Max_Row);

	// Level 3 => Column 209~224
		Fill_Block(0x22,0x34,0x37,0x00,Max_Row);

	// Level 2 => Column 225~240
		Fill_Block(0x11,0x38,0x3B,0x00,Max_Row);

	// Level 1 => Column 241~256
		Fill_Block(0x00,0x3C,Max_Column,0x00,Max_Row);
}
/***************************************
主函数
**************************************/
void main(void)
{

Initial ();
while(1)
{
 /*
Fill_RAM(0xff);
delay(2);
Fill_RAM(0xf0);
delay(2);
Fill_RAM(0x0f);
delay(2);
gedot(0xf0);
delay(2);
gedot(0x0f);
delay(2);
hang(0xff);
delay(2);
hang(0x00);
delay(2);

Fill_RAM(0x00);

//write_oled(0,0,0x00);
//write_oled(4,0,0x01);
biank();
*/

hzwrite_oled(14,0,0x00);
hzwrite_oled(22,0,0x01);
hzwrite_oled(30,0,0x02);
hzwrite_oled(38,0,0x03);
string88(0,17,32);
stinghz(4,25,10) ;
string816(14,45,10);delay(2);



                Vertical_Scroll(0x00,0x01,0x40); //up 						// Upward
		delayms(2);
		Vertical_Scroll(0x01,0x01,0x40); // Downward
                delayms(2);
                Vertical_Scroll(0x00,0x01,0x40); //up 						// Upward
		delayms(2);
		Vertical_Scroll(0x01,0x01,0x40); // Downward
		/*
		Set_Display_Offset(0x00);
		Fade_Scroll(0x03,0x01,0x40);	// Downward - Out
		delayms(1);
		Fade_Scroll(0x00,0x01,0x40);	// Upward - In
		Fade_Scroll(0x02,0x01,0x40);	// Upward - Out
		delayms(1);
		Fade_Scroll(0x01,0x01,0x40);	// Downward - In
		Set_Start_Line(0x00);   */
		delayms(3);
                gedot(0x0f);
                delay(2);
                Grayscale();
                delay(6);
                Fill_RAM(0x00);			// Clear Screen
}}


